type: edu
files:
  - name: tictactoe.py
    visible: true
    text: |
      def print_board(board):
          print('---------')
          print(f'| {board[0][2]} {board[1][2]} {board[2][2]} |')
          print(f'| {board[3][2]} {board[4][2]} {board[5][2]} |')
          print(f'| {board[6][2]} {board[7][2]} {board[8][2]} |')
          print('---------')
      
      
      def input_check(board, turn):
          allowed = [1, 2, 3]
          global x
          global y
          check = True
          while check:
              try:
                  x, y = input().split()
                  x = int(x)
                  y = int(y)
              except:
                  print('You should only enter numbers!')
                  continue
              if x not in allowed or y not in allowed:
                  print('Coordinates should be from 1 to 3!')
                  continue
              for i in range(0, 9):
                  if board[i][0] == x and board[i][1] == y and ('X' in board[i][2] or 'O' in board[i][2]):
                      print('This cell is occupied! Choose another one!')
                      break
                  elif board[i][0] == x and board[i][1] == y and ' ' in board[i][2]:
                      board[i][2] = turn
                      check = False
          return int(x), int(y)
      
      
      def win_check(board, turn, turns):
          wins = [board[0:3][2], board[3:6][2], board[6:9][2], board[0][2] + board[3][2] + board[6][2], board[1][2] +
                  board[4][2] + board[7][2], board[2][2] + board[5][2] + board[8][2], board[0][2] + board[4][2] + board[8][2],
                  board[6][2] + board[4][2] + board[2][2]]
          global end
          if turns == 9 and 'XXX' not in wins and 'OOO' not in wins:
              print_board(board)
              print('Draw')
              end = False
          elif 'XXX' in wins and turn == 'X':
              print_board(board)
              print('X wins')
              end = False
          elif 'OOO' in wins and turn == 'O':
              print_board(board)
              print('O wins')
              end = False
          return
      
      
      def create_start_state(board, start):
          for i in range(0, 9):
              if start[i] == '_':
                  board[i][2] = ' '
              else:
                  board[i][2] = start[i]
          return board
      
      
      def main():
          board = [[1, 1, ' '], [1, 2, ' '], [1, 3, ' '], [2, 1, ' '], [2, 2, ' '], [2, 3, ' '], [3, 1, ' '], [3, 2, ' '],
                   [3, 3, ' ']]
          global x
          global y
          x = 0
          y = 0
          turn = 'X'
          turns = 0
          end = True
          print('Enter the cells: ')
          start_state = input()
          create_start_state(board, start_state)
          while end:
              print_board(board)
              input_check(board, turn)
              #turns += 1
              #win_check(board, turn, turns)
              #if turn == 'X':
                  #turn = 'O'
              #elif turn == 'O':
                  #turn = 'X'
      
      
      if __name__ == "__main__":
          main()
    learner_created: false
  - name: Storage
    visible: true
    text: |
      def print_board(board):
          print('---------')
          print(f'| {board[0][2]} {board[1][2]} {board[2][2]} |')
          print(f'| {board[3][2]} {board[4][2]} {board[5][2]} |')
          print(f'| {board[6][2]} {board[7][2]} {board[8][2]} |')
          print('---------')
      
      
      def input_check(board, turn):
          allowed = [1, 2, 3]
          global x
          global y
          check = True
          while check:
              try:
                  x, y = input().split()
                  x = int(x)
                  y = int(y)
              except:
                  print('You should only enter numbers!')
                  continue
              if x not in allowed or y not in allowed:
                  print('Coordinates should be from 1 to 3!')
                  continue
              for i in range(0, 9):
                  if board[i][0] == x and board[i][1] == y and ('X' in board[i][2] or 'O' in board[i][2]):
                      print('This cell is occupied! Choose another one!')
                      break
                  elif board[i][0] == x and board[i][1] == y and ' ' in board[i][2]:
                      board[i][2] = turn
                      check = False
          return int(x), int(y)
      
      
      def win_check(board, turn, turns):
          wins = [board[0:3][2], board[3:6][2], board[6:9][2], board[0][2] + board[3][2] + board[6][2], board[1][2] +
                  board[4][2] + board[7][2], board[2][2] + board[5][2] + board[8][2], board[0][2] + board[4][2] + board[8][2],
                  board[6][2] + board[4][2] + board[2][2]]
          global end
          if turns == 9 and 'XXX' not in wins and 'OOO' not in wins:
              print_board(board)
              print('Draw')
              end = False
          elif 'XXX' in wins and turn == 'X':
              print_board(board)
              print('X wins')
              end = False
          elif 'OOO' in wins and turn == 'O':
              print_board(board)
              print('O wins')
              end = False
          return
      
      
      def main():
          board = [[1, 1, ' '], [1, 2, ' '], [1, 3, ' '], [2, 1, ' '], [2, 2, ' '], [2, 3, ' '], [3, 1, ' '], [3, 2, ' '],
                   [3, 3, ' ']]
          global x
          global y
          x = 0
          y = 0
          turn = 'X'
          turns = 0
          end = True
          while end:
              print_board(board)
              input_check(board, turn)
              turns += 1
              win_check(board, turn, turns)
              if turn == 'X':
                  turn = 'O'
              elif turn == 'O':
                  turn = 'X'
      
      
      if __name__ == "__main__":
          main()
    learner_created: false
  - name: test/__init__.py
    visible: false
    learner_created: false
  - name: test/tests.py
    visible: false
    text: |
      from copy import copy
      
      from hstest import StageTest, dynamic_test, TestedProgram, CheckResult
      
      from util.enum import GameState, CellState
      from util.grid import Grid
      from util.minimax import Minimax
      
      
      class Test:
          def __init__(self, inp, result, state, additional_contains=None):
              self.inp = inp
              self.result = result
              self.state = state
              self.additional_contains = additional_contains
      
      
      class TicTacToeTests(StageTest):
          easy_ai_moves = [0 for _ in range(9)]
      
          @dynamic_test(order=1)
          def test_bad_parameters(self):
              program = TestedProgram()
              program.start()
      
              output = program.execute("start")
      
              if "bad parameters" not in output.lower():
                  return CheckResult.wrong("After entering start command with wrong parameters you should print "
                                           "'Bad parameters!' and ask to enter a command again!")
      
              output = program.execute("start easy")
      
              if "bad parameters" not in output.lower():
                  return CheckResult.wrong("After entering start command with wrong parameters you should print "
                                           "'Bad parameters!' and ask to enter a command again!")
      
              program.execute("exit")
      
              if not program.is_finished():
                  return CheckResult.wrong("After entering 'exit' command you should stop the program!")
      
              return CheckResult.correct()
      
          @dynamic_test(order=2)
          def test_grid_output(self):
              program = TestedProgram()
              program.start()
      
              output = program.execute("start user easy")
      
              printed_grid = Grid.from_output(output)
              empty_grid = Grid.from_line("_________")
      
              if printed_grid != empty_grid:
                  return CheckResult.wrong(f"After starting the program you should print an empty grid!\n"
                                           f"Correct empty grid:\n{empty_grid}")
      
              if "enter the coordinates:" not in output.lower():
                  return CheckResult.wrong("After printing an empty grid you should ask to enter cell coordinates!")
      
              output = program.execute("2 2")
      
              grid_after_move = Grid.from_output(output)
              correct_grid_after_move = Grid.from_line("____X____")
      
              if grid_after_move != correct_grid_after_move:
                  return CheckResult.wrong(f"After making the move wrong grid was printed.\n"
                                           f"Your grid:\n{grid_after_move}\n"
                                           f"Correct grid:\n{correct_grid_after_move}")
      
              if "making move level \"easy\"" not in output.lower().replace("'", "\""):
                  return CheckResult.wrong("After entering a cell coordinates you should print:\n"
                                           "Making move level \"easy\"")
      
              grid_after_ai_move = Grid.from_output(output, 2)
      
              if grid_after_ai_move == grid_after_move:
                  return CheckResult.wrong("After AI move grid wasn't changed!")
      
              game_grid = grid_after_ai_move
      
              while True:
                  game_state = game_grid.get_game_state()
                  if game_grid.get_game_state() != GameState.NOT_FINISHED:
                      if game_state == GameState.X_WIN and "X wins" not in output:
                          return CheckResult.wrong("You should print 'X wins' if X win the game!")
                      if game_state == GameState.O_WIN and "O wins" not in output:
                          return CheckResult.wrong("You should print 'O wins' if O win the game!")
                      if game_state == GameState.DRAW and "Draw" not in output:
                          return CheckResult.wrong("You should print 'Draw' if the game ends with draw!")
                      break
      
                  next_move = Minimax.get_move(game_grid, CellState.X)
                  temp_grid = copy(game_grid)
      
                  temp_grid.set_cell(next_move.x, next_move.y, CellState.X)
      
                  output = program.execute(f"{next_move.x + 1} {next_move.y + 1}")
      
                  game_grid = Grid.from_output(output)
      
                  if game_grid != temp_grid:
                      return CheckResult.wrong(f"After making move ({next_move}) the grid is wrong!\n"
                                               f"Your grid:\n{game_grid}\n"
                                               f"Correct grid:\n{temp_grid}")
      
                  if game_grid.get_game_state() != GameState.NOT_FINISHED:
                      continue
      
                  game_grid = Grid.from_output(output, 2)
      
              return CheckResult.correct()
      
          @dynamic_test(repeat=100, order=3)
          def check_easy_ai(self):
      
              program = TestedProgram()
              program.start()
      
              program.execute("start user easy")
      
              output = program.execute("2 2")
      
              grid_after_ai_move = Grid.from_output(output, 2)
      
              cells = grid_after_ai_move.get_grid()
      
              for i in range(9):
                  if i == 4:
                      continue
      
                  if cells[int(i / 3)][i % 3] == CellState.O:
                      self.easy_ai_moves[i] += 1
      
              return CheckResult.correct()
      
          @dynamic_test(order=4)
          def check_random(self):
      
              average_score = 0
      
              for i in range(len(self.easy_ai_moves)):
                  average_score += (i + 1) * self.easy_ai_moves[i]
      
              average_score /= 8
      
              expected_value = (1 + 2 + 3 + 4 + 6 + 7 + 8 + 9) * 100 / 8 / 8
      
              if abs(average_score - expected_value) > 20:
                  return CheckResult.wrong("Looks like your Easy level AI doesn't make a random move!")
      
              return CheckResult.correct()
      
          is_easy_not_moving_like_medium = False
      
          @dynamic_test(repeat=30, order=-5)
          def check_easy_not_moving_like_medium(self):
      
              if self.is_easy_not_moving_like_medium:
                  return CheckResult.correct()
      
              program = TestedProgram()
              program.start()
      
              program.execute("start user easy")
      
              output = program.execute("2 2")
      
              game_grid = Grid.from_output(output, 2)
      
              cells = game_grid.get_grid()
      
              if cells[0][0] == CellState.EMPTY and cells[2][2] == CellState.EMPTY:
                  output = program.execute("1 1")
                  game_grid = Grid.from_output(output, 2)
                  if game_grid.get_grid()[2][2] == CellState.EMPTY:
                      self.is_easy_not_moving_like_medium = True
              else:
                  output = program.execute("1 3")
                  game_grid = Grid.from_output(output, 2)
                  if game_grid.get_grid()[2][0] == CellState.EMPTY:
                      self.is_easy_not_moving_like_medium = True
      
              return CheckResult.correct()
      
          @dynamic_test(order=6)
          def check_easy_not_moving_like_medium_after(self):
              if not self.is_easy_not_moving_like_medium:
                  return CheckResult.wrong("Looks like your Easy level AI doesn't make a random move!")
              return CheckResult.correct()
      
          @dynamic_test(order=7)
          def check_easy_vs_easy(self):
      
              program = TestedProgram()
              program.start()
      
              output = program.execute("start easy easy")
      
              grids = Grid.all_grids_from_output(output)
      
              Grid.check_grid_sequence(grids)
      
              return CheckResult.correct()
      
          @dynamic_test(repeat=10, order=8)
          def check_medium_ai(self):
      
              program = TestedProgram()
              program.start()
              program.execute("start user medium")
      
              output = program.execute("2 2")
      
              game_grid = Grid.from_output(output, 2)
      
              cells = game_grid.get_grid()
      
              if cells[0][0] == CellState.EMPTY and cells[2][2] == CellState.EMPTY:
                  output = program.execute("1 1")
                  game_grid = Grid.from_output(output, 2)
                  if game_grid.get_grid()[2][2] == CellState.EMPTY:
                      return CheckResult.wrong("Looks like your Medium level AI doesn't make a correct move!")
              else:
                  output = program.execute("1 3")
                  game_grid = Grid.from_output(output, 2)
                  if game_grid.get_grid()[2][0] == CellState.EMPTY:
                      return CheckResult.wrong("Looks like your Medium level AI doesn't make a correct move!")
      
              return CheckResult.correct()
      
          @dynamic_test(order=9)
          def check_medium_vs_medium(self):
      
              program = TestedProgram()
              program.start()
      
              output = program.execute("start medium medium")
      
              grids = Grid.all_grids_from_output(output)
      
              Grid.check_grid_sequence(grids)
      
              return CheckResult.correct()
      
          is_medium_not_moving_like_hard = False
      
          @dynamic_test(repeat=30, order=10)
          def check_medium_not_moving_like_hard(self):
      
              if self.is_medium_not_moving_like_hard:
                  return CheckResult.correct()
      
              program = TestedProgram()
              program.start()
      
              program.execute("start user medium")
      
              output = program.execute("2 2")
      
              user_move_grid = Grid.from_output(output, 1)
              medium_move_grid = Grid.from_output(output, 2)
      
              medium_move = Grid.get_move(user_move_grid, medium_move_grid)
      
              minimax_correct_positions = Minimax.get_available_positions(user_move_grid, CellState.O)
      
              if medium_move not in minimax_correct_positions:
                  self.is_medium_not_moving_like_hard = True
      
              return CheckResult.correct()
      
          @dynamic_test(order=11)
          def check_medium_not_moving_like_hard_after(self):
              if not self.is_medium_not_moving_like_hard:
                  return CheckResult.wrong("Looks like Medium level AI doesn't make a random move!")
              return CheckResult.correct()
      
      
      if __name__ == '__main__':
          TicTacToeTests().run_tests()
    learner_created: false
  - name: tests.py
    visible: false
    text: |-
      from test.tests import TicTacToeTests
      
      if __name__ == '__main__':    TicTacToeTests().run_tests()
    learner_created: false
  - name: test.py
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/7442#comment
status: Solved
feedback:
  message: Congratulations!
  time: "Sat, 20 Apr 2024 07:44:50 UTC"
record: 4
